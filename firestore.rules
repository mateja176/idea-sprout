rules_version = '2';

function isSignedIn() {
  return request.auth != null;
}

function isAuthor() {
  return resource.data.author == request.auth.uid;
}

function isIdeaMine() {
  return isSignedIn() && isAuthor();
}

function isGuest() {
  return isSignedIn() && !isAuthor();
}

function willBeAuthor() {
  return request.resource.data.author == request.auth.uid;
}

function canCreateIdea() {
  return request.resource.data.averageRating == 0
    && request.resource.data.ratingCount == 0
    && request.resource.data.sharedBy.size() ==0
    && willBeAuthor();
}

function notUpdatingRating() {
  return request.resource.data.diff(resource.data).unchangedKeys().hasAll(['averageRating', 'ratingCount']);
}

function notUpdatingSharedBy() {
  return request.resource.data.diff(resource.data).unchangedKeys().hasAll(['sharedBy']);
}

function onlyUpdatingRating() {
  return request.resource.data.diff(resource.data).changedKeys().hasOnly(['averageRating', 'ratingCount']);
}

function canCreateReview() {
  return onlyUpdatingRating() &&
    request.resource.data.ratingCount == resource.data.ratingCount + 1;
}

function canUpdateReview() {
  return onlyUpdatingRating() &&
    request.resource.data.ratingCount == resource.data.ratingCount;
}

function isRatingValid() {
  return request.resource.data.rating is int && request.resource.data.rating >= 1 && request.resource.data.rating <= 5;
}
function isFeedbackValid() {
  return request.resource.data.feedback is string;
}
function isReviewType() {
  return request.resource.data.keys().hasOnly(['rating', 'feedback'])
    && isRatingValid()
    && isFeedbackValid();
}

function isCountType() {
  return request.resource.data.keys().hasOnly(['count'])
    && request.resource.data.count is int;
}

service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if false;
    }
    match /ideas/{ideaId} {
      allow read: if isSignedIn() && (isAuthor() || resource.data.status == 'sprout');
      allow create: if isSignedIn() && canCreateIdea();
      allow update: if willBeAuthor() && (isIdeaMine() && notUpdatingRating() && notUpdatingSharedBy()) ||
        (isGuest() &&
          !exists(
            /databases/$(database)/documents/ideas/$(ideaId)/reviews/$(request.auth.uid)
          ) &&
          canCreateReview() &&
          request.resource.data.averageRating ==
            (resource.data.averageRating * resource.data.ratingCount +
              getAfter(
                /databases/$(database)/documents/ideas/$(ideaId)/reviews/$(request.auth.uid)
              ).data.rating) /
              (resource.data.ratingCount + 1)) ||
        (isGuest() &&
          exists(
            /databases/$(database)/documents/ideas/$(ideaId)/reviews/$(request.auth.uid)
          ) &&
          canUpdateReview() &&
          request.resource.data.averageRating ==
            (resource.data.averageRating * resource.data.ratingCount -
              get(
                /databases/$(database)/documents/ideas/$(ideaId)/reviews/$(request.auth.uid)
              ).data.rating +
              getAfter(
                /databases/$(database)/documents/ideas/$(ideaId)/reviews/$(request.auth.uid)
              ).data.rating) /
              resource.data.ratingCount);

      match /reviews/{userId} {
        allow read: if isSignedIn();
        allow write: if isSignedIn() && userId == request.auth.uid && isReviewType();
      }
    }

    match /counts/ideas {
      allow read: if isSignedIn();
      // ? is there a way to check what the other operation contained in the batch is
      allow write: if isSignedIn() && isCountType() && (request.resource.data.count - resource.data.count) == 1;
    }
  }
}
